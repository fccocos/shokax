---
title: 一位补码乘法的设计与实现
date: '2023/6/11 23:00'
math: true
---





# 一位补码乘法的设计与实现

##  一、实验原理

> **原理概述**：一位补码乘法运算又叫booth运算，其操作的主要步骤主要为移位和加减法两步操作。sua

### 算法实现步骤

设$X_n$为被乘数，$Y_n$为乘数，$P_{2n}$为部分积，其中部分积两个符号位，设为$P_{S_1}P_{S_2}$，乘数一位符号位,设为$Y_{S_1}$, 被乘数两位符号位$X_{S_1}X_{S_2}$,剩下好一个附加位（用于与部分积的最低位组成操作标记），设为$P_0$ 具体看如下:
$$
\begin{align}
& X = X_{S_1}X_{S_2}, X_n X_{n-1} X_{n-2}\cdots X_2 X_1 \\
& Y = Y_{S_1}\,\,\,\,\,\,\,\,\,\,\,\,,Y_n Y_{n-1} Y_{n-2} \cdots Y_2 Y_1 \\
& P = P_{S_1}P_{S_2}, P_{2n}P_{2n-1}P_{2n-1}\cdots P_2 P_1 P_0 \\
\end{align}
$$

1. 初始化$X=0$,$Y=0$,$P=0$

   | 被乘数$X_i$ | 符号位$X_{S_1}X_{S_2}$ |   被乘数   |       乘数 | 附加位与移位舍弃位 |
   | ----------- | ---------------------- | :--------: | ---------: | :----------------- |
   | $X$         | 00                     |  00000000  |            |                    |
   | 乘数$Y_i$   | 符号位$Y_{S_1}$        |            |            |                    |
   | $Y$         | 0                      |            |   00000000 |                    |
   | 部分积$P_i$ | 符号位$P_{S_1}P_{S_2}$ | 部分积高位 | 部分积低位 |                    |
   | $P_i$       | 00                     |  00000000  |   00000000 | 0                  |

2. 将真值乘数与真值被乘数转换为补码，并将其载入，设$X = -01110111,\, Y = -10110111$，则其对应的补码为 $[X]_{comp}=11,\,10001001 , \, [-X]_{comp} = [[X]_{comp}]_{neg}+1 = 00,\,01110111;\,[Y]_{comp} = 11,01001001$, 并将乘数载入部分积地位中，如下如所示：

| 被乘数$X_i$ | 符号位$X_{S_1}X_{S_2}$ |     被乘数      |       乘数 | 附加位与移位舍弃位 |
| ----------- | ---------------------- | :-------------: | ---------: | :----------------- |
| $X$         | 11                     |    10001001     |            |                    |
| 乘数$Y_i$   |                        | 符号位$Y_{S_1}$ |            |                    |
| $Y$         |                        |        1        |   01001001 |                    |
| 部分积$P_i$ | 符号位$P_{S_1}P_{S_2}$ |   部分积高位    | 部分积低位 |                    |
| $P_i$       | 11                     |    00000000     | 0100100`1` | `0`                |

3. 查看附加位和乘数最低位，查看代码对应的移位规则,进行对应的操作

   | $Y_1$ | $Y_0$ |                                                    |
   | ----- | ----- | -------------------------------------------------- |
   | 0     | 0     | 部分积右移一位                                     |
   | 0     | 1     | 部分积加被乘数的补码$[X]_{comp}$, 然后右移一位     |
   | 1     | 0     | 部分积加被乘数负数的补码$[-X]_{comp},然后右移一位$ |
   | 1     | 1     | 部分积右移一位                                     |

4. 按照对应规则，将部分积与被乘数相加

| 被乘数$X_i$   | 符号位$X_{S_1}X_{S_2}$ |     被乘数      |         乘数 | 附加位与移位舍弃位   |
| ------------- | ---------------------- | :-------------: | -----------: | :------------------- |
| $X$           | 11                     |    10001001     |              |                      |
| 乘数$Y_i$     |                        | 符号位$Y_{S_1}$ |              |                      |
| $Y$           |                        |        1        |     01001001 |                      |
| 部分积$P_i$   | 符号位$P_{S_1}P_{S_2}$ |   部分积高位    |   部分积低位 |                      |
| $P_i$         | 11                     |    00000001     |   0100100`1` | `0`                  |
|               |                        |                 |              |                      |
| $+[X]_{comp}$ | 11                     |    10001001     |              | 10代码，加被乘数补码 |
| $P_i$         | 11                     |    00000001     |   0100100`1` | `0`                  |
| res           | 00                     |    10001010     | 0100100`1  ` | `0`                  |

5. 对部分积进行右移一位操作

| 被乘数$X_i$   | 符号位$X_{S_1}X_{S_2}$ |          被乘数 |         乘数 | 附加位与移位舍弃位   |
| ------------- | :--------------------: | --------------: | -----------: | :------------------- |
| $X$           |           11           |        10001001 |              |                      |
| 乘数$Y_i$     |                        | 符号位$Y_{S_1}$ |              |                      |
| $Y$           |                        |               1 |     01001001 |                      |
| 部分积$P_i$   | 符号位$P_{S_1}P_{S_2}$ |      部分积高位 |   部分积低位 |                      |
| $P_i$         |           11           |        00000001 |   0100100`1` | `0`                  |
|               |                        |                 |              |                      |
| $+[X]_{comp}$ |           11           |        10001001 |              | 10代码，加被乘数补码 |
| $P_i$         |           11           |        00000001 |   0100100`1` | `0`                  |
| res           |           00           |        10001010 | 0100100`1  ` | `0`                  |
|               |                        |                 |              |                      |
| 右移一位      |                        |                 |              | 补码右移，高位补一   |
| res           |           10           |        01000101 |   0010010`0` | `1`0                 |

6. 重复3-4步骤，直到乘数被完全移出，结束操作。



### ChatGPT给出的Booth算法流程

1. 选择两个操作数A和S
2. 创建一个寄存器Q，将A的值存储在Q的左边，将S的值存储在Q的右边
3. 将一个计数器C初始化为0（代表已经执行的步骤数）
4. 循环执行以下步骤，直到C的值等于n（代表要进行的操作次数）为止：
   a. 如果Q的最低有效位为01，执行Q = Q + S，否则如果最低有效位为10，执行Q = Q - S
   b. 将Q向右移一位
   c. 将C加1

以上就是Booth算法的基本流程。在每次执行Q = Q + S 或 Q = Q - S 时，都会先检查最低有效位是否为01或10，决定是否执行加法或减法操作。每次执行完一个操作后，都将Q向右移一位以准备下一次操作。执行操作的次数根据n来确定。



### Booth算法流程

![booth算法流程图](https://gitee.com/fangcongss/blog-pic/raw/master/img/booth%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

## 二、实验目的

1. 熟悉booth算法
2. 能够用booth算法设计一个乘法器

## 三、实验任务

1. 在logisim中利用ALU设计一个16位的乘法器
2. 用随机数生成器，生成随机测试乘法器的准确性
3. 用C语言实现booth算法，并提供可用的接口，方便调用

## 四、设计图和设计原理分析

### 实验所用逻辑部件

- n+2位加法器

- 三个n+2位寄存器A，Q，X（A用于存放积的高位，Q用于存放积的地位或乘数的符号位和附加位，X用于存放被乘数）
- 计数器

### 逻辑图

## 五、实验内容及结果





## 六、实验扩展



### （1）算法实现



### （2）乘法矩阵的设计思路



