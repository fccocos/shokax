---
title: 第二章 进程与线程
math: true
date: 2023-08-20 15:42:54
---

{% markmap 750px %}

- 进程与线程

  - 进程与线程

    - 进程的概念和特征
      - 进程的概念
        - 进程：描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特征）
        - 进程控制块（PCB）：PCB是进程存在的唯一标志
        - 进程实体（进程映像）：由程序段、相关数据和PCB一起构成
        - 进程创建：创建进程实体中的PCB
        - 撤销进程：撤销进程实体中的PCB
        - 进程映像是静态的，进程是动态的
        - 三种经典的进程定义
          - 进程是程序的一次执行过程
          - 进程是一个程序及其数据在处理机上顺序执行所发生的活动
          - 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位
        - 引入进程实体概念后的进程定义：进程是进程实体的运行过程，是系统进行资源分配和调度的独立单位。
      - 进程的特征（对比单个程序提出的）
        - 动态性（进程的基本特征）
        - 并发性（进程的重要特征）
        - 独立性
        - 异步性
    - 进程的状态与转换
      - 五种状态
        - 运行态：进程正在处理机上运行
        - 就绪态：进程获得了除处理机外的一切资源，一旦获得处理机，便可立即运行
        - 阻塞态（等待态）：进程正在等待某一事件发生而暂停运行
        - 创建态：进程正在被创建，尚未转到就绪态
        - 终止态：进程正在从系统中消失，可能是进程正常结束或其他原因退出运行。
      - 运行态、就绪态和阻塞态之间的转换极其触发条件
        - 就绪态$\to$运行态: 获得处理机
        - 运行态$\to$就绪态：时间片用完、处理被剥夺
        - 运行态$\to$阻塞态：等待某事件发生
        - 阻塞态$\to$就绪态：等待的事件到来了
        - 进程从运行态到阻塞态是主动的行为，而从阻塞态到就绪态是被动的行为，需要其他相关进程的帮助。

    - 进程的组成
      - 进程控制块（PCB）（系统只有通过进程的PCB才能感知到进程的存在）
        - 进程的生命周期
          - 进程创建时，操作系统为该进程创建一个PCB，该PCB会常驻内存，任意时刻都可存取，并在进程结束时删除。
          - 进程执行时，系统通过进程的PCB了解进程的现行运行状态信息，以便于系统对其进行控制和处理；进程结束时，系统回收PCB，进程随之消亡。
          - 当操作系统将要调度某进程时，要从该进程的PCB中查出其现行状态及优先级；
          - 在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；
          - 进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB
          - 当进程由于某种原因而暂停运行时，又需要将其断电的处理环境保存在PCB中。
        - 继承控制块的组成
          - 进程描述信息
            - 进程描述符(PID): 标志各个进程，每个进程都有一个唯一的标示号
            - 用户描述符(UID): 进程归属的用户，用户标识符主要为共享和保护服务
            - 。。。。。。
          - 进程控制和管理信息
            - 进程当前转态
            - 进程优先级
            - 。。。。。。
          - 资源分配清单：用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息
          - 处理机相关信息（处理机上下文）：主要指处理机中各种寄存器的值。
      - 程序段：能够被进程调度程序调度到CPU执行的程序代码段
      - 数据段：可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。
    - 进程的控制
      - 功能：对系统中的所有进程实施有效的管理
        - 创建新进程
        - 撤销已有进程
        - 实现进程状态转换
      - 原语：进程控制用的程序
        - 特点：执行期间不可分割，它是一个不可分割的基本单位
      - 进程创建
        - 父进程：子进程的创建者
        - 子进程：被创建的进程
        - 子进程可以拥有父进程所有的资源
        - 子进程撤销时，要将其从父进程中获取的资源归还给父进程。
        - 父进程撤销时，其所有的子进程都会被撤销
        - 创建原语（操作系统创建一个新进程的过程）
          - 分配PID，申请PCB
          - 分配资源
          - 初始化PCB
          - 加入就绪队列，等待被调度运行
      - 进程的终止
        - 引起进程终止的事件
          - 正常结束
          - 异常结束
          - 外界干扰
        - 终止原语（操作系统终止进程的过程）
          - 根据PID，检索PCB，读出状态
          - 若处于运行态，立即终止执行，将处理机分配给其他进程
          - 终止其所有的子孙进程
          - 释放资源，归还给父进程或操作系统
          - 从队列（链表）中删除PCB
      - 进程的阻塞和唤醒
        - 进程的阻塞：正在运行的进程，由于期待的某事件没有发生，进程通过调用阻塞原语，使自己由运行态变为阻塞态
          - 阻塞是进程自身的一种主动行为，故只有处于运行态下的进程才可以变为阻塞态。
          - 阻塞原语的执行过程
            - 通过PID找PCB
            - 如果为运行态，则保护现场，将其状态变为阻塞态并停止运行
            - 将PCB插入对应事件的等待队列中，让出处理机资源
        - 进程的唤醒：处理等待队列的进程，由于等待的事件发生了，由相关进程调用唤醒原语，将等待该事件的进程唤醒。
          - 唤醒原语的执行过程
            - 在相应事件的等待队列中找PCB
            - 将PCB从等待队列中移出，并将其状态置为就绪态
            - 将PCB插入到就绪队列中，等待调度程序的调度
    - 进程的通信：进程间的信息交换
      - 低级通信：PV操作
      - 高级通信：指以较高的效率传输大量数据的通信方式
        - 共享存储：在通信的进程之间存在一个可直接访问的共享空间，通过对这片空间进程读写操作实现进程间的信息交换。
        - 两种共享存储方式
          - 低级方式: 基于数据结构的共享
          - 高级方式：基于存储区的共享
        - 通信过程
          - 操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读写指令完成。
      - 消息传递：在消息传递系统中，进程间的数据交换以格式化的消息为单位
        - 接收消息原语
        - 发送消息原语
        - 微内核与服务器之间的通信采用了消息传递机制
        - 消息传递方式
          - 直接通信方式：发送进程把消息发送给接收进程，并将其挂在接收进程的消息缓冲队列上，接收进程从消息列中取得消息
          - 间接通信方式：发送进程把消息发送到某个中间体，接收进程从中间实体获得消息。
      - 管道通信
    - 线程与多线程模型
      - 线程的基本概念
        - 一个基本的CPU执行单元，程序执行流的最小单位
        - 进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的资源
        - 一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行
        - 由于线程之间的相互制约，致使线程在运行期间呈现出间断性。
        - 线程也有创建、阻塞和运行三种基本状态
        - 线程的组成：TID，程序计数器，寄存器集合和堆栈
        - 引入线程后，进程只作为除处理机外的资源分配单位，而线程则作为处理机的分配单位。
      - 进程和线程的比较
        - 调度
        - 并发性
        - 拥有资源
        - 独立性
        - 系统开销
        - 支持多处理机系统
      - 线程的属性
        - 线程是一个轻型实体，他不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态
        - 不同的线程可以执行相同的程序
        - 同一进程中的各个线程共享该进程所拥有的资源
        - 线程是处理机的调度单位，多个线程是可以并发执行
        - 一个线程被创建后，便开始了他的生命周期，直至终止
      - 线程的状态和转换
        - 执行状态
        - 就行转态
        - 阻塞转态
        - 转换和进程一样
      - 线程的组织与控制
        - 线程控制块
          - TID
          - 寄存器组
          - 线程运行状态
          - 优先级
          - 线程专有存储区
          - 堆栈指针
        - 线程创建
        - 线程终止
      - 线程的实现方式
        - 用户级线程（ULT）
          - 优点：
            - 线程切换不需要转换到内核空间，节省了模式切换的开销
            - 调用算法可以是进程专用的，不同线程可根据自身的需要，对自己的线程选择不同的调度算法
            - 用户级线程的实现与操作系统平台无关，对线程管理代码是属于用户程序的一部分
          - 缺点
            - 系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞
            - 不能发挥多处理机的优势，内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程执行。
        - 内核级线程（KLT）
          - 优点
          - 缺点
        - 组合方式
          - 线程库两种实现方式
      - 多线程模型
        - 多对一模型
        - 一对一模型
        - 多对多模型

  - 处理机调度

    - 调度的概念
    - 调度的目标
    - 调度的实现
    - 经典的调度算法
    - 进程切换

  - 同步与互斥

    - 同步与互斥的基本概念
    - 实现临界区互斥的基本方法
    - 互斥锁
    - 信号量
    - 管程
    - 经典同步问题

  - 死锁

    - 死锁的概念
    - 死锁预防
    - 死锁避免
    - 死锁检测和解除

{% endmarkmap %}

### 进程间的同步互斥问题

约定P操作消耗资源，V操作生产资源

#### 利用信号量实现的同步关系

```c++
semaphore S=0;
P1(){
  x;
  V(S) // S++
    // ...
}
P2(){
  //...
  P(S); // S--
  y;
}
```

#### 利用信号量实现互斥关系

```c++
semaphore S=1;
P1()
{
  //...
 P(S); // 加锁, 即表示要占用临界区，故属于消耗资源，执行P操作
 x;    // 进入临界区，执行相关语句
 V(S); // 释放锁, 即表示当前进程出临界区，属于释放资源，执行V操作
 //...
}
P2()
{
  //...
  P(S); // 同上
  y;
  V(S); // 同上
}
```

总结：利用信号量进行同步时，不同进程对一个公共信号量进程PV操作，而进行互斥时，是不同进程对同一信号量进行PV操作。一般同步指两个进程间的同步，即两个不同的进程使用一个公共信号量，而不通组同步进程间的公共信号往往不同，也就说需要设置多个不同的公共信号。

#### 利用信号量实现前驱关系

![前驱关系](https://gitee.com/fangcongss/blog-pic/raw/master/img/%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB.png)

为了保证S1->S2, S1->S3, S2->S4, S2->S5, S4->S6, S5->S6的前驱关系，设置其对应的信号量为a1,a2,b1,b2,c,d.实现算法如下所示：

```c++
semaphore a1=a2=b1=b2=c=d=0; // 信号量初始化
S1(){
  //...        
  V(a1),V(a2);  // S1运行完成
}
S2(){
  P(a1);       // 检查S1是否运行完成
  //...        
  V(b1),V(b2); // S2运行完成
}
S3(){
  P(a2);      // 检查S2是否运行完成
  //...
              // S3运行完成
}
S4(){
  P(b1);      // 检查S2是否运行完成
  //...
  V(c);       // S4运行完成
}
S5(){
  P(b2);      // 检查S2是否运行完成
  //...
  V(d);       // S5运行完成
}
S6(){
  P(c),P(d);  // 检查S4，S5是否运行完成
  //...
}
```



### 经典同步互斥问题

#### 生产者—消费者问题

![生产者消费者问题](https://gitee.com/fangcongss/blog-pic/raw/master/img/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.png) 

分析：

1. 缓冲区属于临界资源，进程访问时需要进行互斥
2. 当缓冲区不为空时，消费者才能取产品，故这里需要对空缓冲区数进行同操作
3. 当缓冲区未满时，生产者才能放产品，故这里也需要对满缓冲区数进行同步操作

信号量的设置：

1. 生产者和消费者之间的互斥关系用信号量mutex表示，默认值为1。
2. 用full和empty信号量分别记录缓冲区“满”和“空”，full初始值为0，empty初始值为n。

算法实现：

```c++
semaphore mutex=1; // 临界区互斥信号量
semaphore empty=n; // 空闲缓冲区
semaphore full=0;  // 缓冲区初始化为空
Producer(){        // 生产者
  while(1){
    //Produce an item in nextp;   // 生产者生产产品
  	P(empty);                     // 获取空缓冲区数
  	P(mutex);                     // 进入临界区
  	//Add a product to buffer;    // 生产者存放产品到缓冲区
  	V(mutex);                     // 生产者离开临界区
  	V(full);                      // 满缓冲区数+1  
  }
  
}
Customer(){
 while(1){
   P(full);                       // 获取满缓冲区数
   P(mutex);                      // 进入临界区
   //remove a product from buffer;// 消费者从缓冲区取走产品
   V(mutex);                      // 离开临界区
   V(empty);                      // 空缓冲区数+1
 }
}
```

#### 爸爸放苹果，女儿吃苹果，妈妈放橘子，儿子吃橘子问题

![生产消费2](https://gitee.com/fangcongss/blog-pic/raw/master/img/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B92.png)

关系分析：

1. 盘子中一次只能放一种水果，故爸爸和妈妈之间是互斥关系
2. 只有爸爸将苹果放到盘子里后女儿才能够吃苹果，故爸爸和女儿之间是同步关系
3. 同理得，妈妈和儿子之间是互斥关系
4. 女儿和儿子之间没有同步互斥关系

设置信号量：

1. 设置plate为互斥信号量，1表示允许放入一种水果，0表示不允许放入水果。
2. 设置apple为爸爸和女儿之间同步关系的信号量，1表示盘子中放的是苹果，0表示盘子中没有苹果。
3. 设置orange为妈妈和儿子之间同步关系的信号量，1表示盘子中放的是橘子，0表示盘子没有橘子。

算法实现：

```c++
semaphore plate=1， apple=0, orange=0;
father(){
  while(1){
      // prepare an apple;
  	P(plate);
  	// put an apple on the plate;
  	V(apple);
  }
}
mother(){
  while(1){
     // prepare an orange;
  	P(plate);
  	// put an orange on the plate;
  	V(orange);
  }
}
daugther(){
  while(1){
    P(apple);
    // take the orange from the plate;
    V(plate);
  }
}
son(){
  while(1){
    P(orange);
    // take the apple from the plate;
    V(platte);
  }
}
```

如果father和mother先后同时要访问临界区，则当father进入临界区后，mother则进入等待队列等待。只有daughter进程结束后，临界资源才能得到释放，此时mother才能进入临界区。

#### 读者—写者问题

##### 读进程优先

```c++
int count=0;
semaphore mutex =1;
semaphore rw=1;
writer(){
  while(){
    P(rw);
  	// write
  	V(rw);
  }
}
reader(){
  while(1){
    P(mutex);
    if(count == 0)
      P(rw);
    count++;
    V(mutex);
    //reading;
    P(mutex);
    if(count==0)
      V(rw);
    V(mutex);
  }
}
```

##### 写进程优先

```c++
int count=0;         // 用于记录当前读者数
semaphore mutex=1;   // 用于保护更新count变量时的互斥
semaphore w=1;       // 用于实现“写优先”
semaphore rw=1;      // 用于实现读者和写者之间的互斥

writer(){
  while(1){
    P(w);            // 在没有写进程请求时进入
    P(rw);           // 互斥访问共享文件
    // write;        // 写入
    V(rw);           // 释放共享文件
    V(w);            // 恢复对共享文件的访问
  }
}
reader(){
  while(1){
    P(w);
    P(mutex);
    if(count==0)
      P(rw);
    count++;
    V(mutex);
    V(w);
    //reading;
    P(mutex);
    count--;
    if(count==0)
      V(rw);
    V(mutext);
  }
}

```

#### 哲学家思考问题

```c++
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex = 1; // 取筷子信号量
Pi(){
  do{
    P(mutex);              // 可以取筷子
    P(chopstick[i]);       // 取左筷子
    P(chopstick[(i+1)%5]); // 取右筷子
    V(mutex);              // 不可筷子
    //eat;                 // 吃饭
    V(chopstick[i]);       // 放下左筷子
    V(chopstick[(i+1)%5]); // 放下右筷子
    // think;              // 进入思考
  }while(1);
}
```

